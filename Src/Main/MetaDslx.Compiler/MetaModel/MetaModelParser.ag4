parser grammar MetaModelParser;

options
{
    tokenVocab = MetaModelLexer; 
}

main: namespaceDeclaration*;

@QualifiedName
qualifiedName : identifier (TDot identifier)*;
identifierList : identifier (TComma identifier)*;
qualifiedNameList : qualifiedName (TComma qualifiedName)*;

@NameCtr(symbolType=MetaNamespace,merge=true)
@Scope
namespaceDeclaration: KNamespace @Property(Name) @Value @NameDef qualifiedName TEquals @Property(Uri) @Value stringLiteral TOpenBrace @Property(Models) metamodelDeclaration* TCloseBrace;

@TypeCtr(MetaModel)
@Scope
metamodelDeclaration: KMetamodel @Property(Name) @Value @TypeDef identifier TOpenBrace @Property(Types) declaration* TCloseBrace;

declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration;

@TypeCtr(MetaEnum)
@Scope
enumDeclaration : KEnum @Property(Name) @Value  @TypeDef identifier TOpenBrace @Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
@NameCtr(MetaEnumLiteral)
enumValue : @Property(Name) @Value  @NameDef identifier;
enumMemberDeclaration : @Property(Operations) operationDeclaration;

@TypeCtr(MetaClass)
@Scope
classDeclaration : @Property(IsAbstract) @Value(true) KAbstract? KClass @Property(Name) @Value @TypeDef identifier (TColon @Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : @TypeUse(MetaClass) qualifiedName;
classMemberDeclaration : @Property(Properties) fieldDeclaration | @Property(Operations) operationDeclaration;

@NameCtr(MetaProperty)
fieldDeclaration : @Property(Kind) fieldModifier? typeReference @Property(Name) @Value @NameDef identifier TSemicolon;
fieldModifier : @Value(MetaPropertyKind.Containment) KContainment | @Value(MetaPropertyKind.Readonly) KReadonly | @Value(MetaPropertyKind.Lazy) KLazy | @Value(MetaPropertyKind.Derived) KDerived;

//@NameCtr(MetaConstant)
constDeclaration : KConst typeReference /*@NameDef*/ identifier /*(TEquals expression)?*/ TSemicolon;

@TypeUse
returnType : typeReference | voidType;
@TypeUse
typeReference : collectionType | simpleType;
@TypeUse
simpleType : primitiveType | objectType | nullableType | qualifiedName;

@TypeCtr(symbolType=MetaPrimitiveType, merge=true)
objectType 
	: @PreDefSymbol(MetaBuiltInType.Object) KObject 
	| @PreDefSymbol(MetaBuiltInType.String) KString
	;
@TypeCtr(symbolType=MetaPrimitiveType, merge=true)
primitiveType 
	: @PreDefSymbol(MetaBuiltInType.Int) KInt 
	| @PreDefSymbol(MetaBuiltInType.Long) KLong 
	| @PreDefSymbol(MetaBuiltInType.Float) KFloat 
	| @PreDefSymbol(MetaBuiltInType.Double) KDouble 
	| @PreDefSymbol(MetaBuiltInType.Byte) KByte 
	| @PreDefSymbol(MetaBuiltInType.Bool) KBool
	;
@TypeCtr(symbolType=MetaPrimitiveType, merge=true)
voidType : @PreDefSymbol(MetaBuiltInType.Void) KVoid;

@TypeCtr(MetaNullableType)
nullableType : @Property(InnerType) primitiveType TQuestion;

@TypeCtr(MetaCollectionType)
collectionType : @Property(Kind) collectionKind TLessThan @Property(InnerType) simpleType TGreaterThan;
collectionKind : @Value(MetaCollectionKind.Set) KSet | @Value(MetaCollectionKind.List) KList;

@NameCtr(MetaOperation)
@TypeCtr(symbolType=MetaOperation, noScope=true)
@Scope
operationDeclaration : KStatic? @Property(ReturnType) returnType @Property(Name) @Value @TypeDef @NameDef identifier TOpenBracket @Property(Parameters) parameterList? TCloseBracket TSemicolon;
parameterList : parameter (TComma parameter)*;

@NameCtr(MetaParameter)
parameter : @Property(Type) typeReference @NameDef identifier /*(TEquals expression)? { expression.ExpectedType = typeReference; }*/;

/*
expressionList : expression (',' expression)*; 

@Expression
expression 
	: '(' typeReference ')' expression #castExpression @Symbol(TypeConversionExpression) { Type = typeReference; }
    | 'typeof' '(' typeReference ')' #typeofExpression @Symbol(TypeOfExpression) { Type = typeof(MetaType); }
	| '(' expression ')' #bracketExpression @Symbol(BracketExpression) { Type = expression.Type; expression.ExpectedType = ExpectedType; }
	| literal #constantExpression @Symbol(ConstantExpression) { literal.ExpectedType = ExpectedType; }
	| identifier #identifierExpression @Symbol(IdentifierExpression) { identifier.ExpectedType = ExpectedType; Definition = bind; Type = Definition.Type; }
    | expression '[' expressionList ']' #indexerExpression @Symbol(IndexerExpression) { Definition = bind; Type = Definition.ReturnType; }
    | expression '(' expressionList? ')' #functionCallExpression @Symbol(FunctionCallExpression) { Definition = bind; Type = Definition.ReturnType; }
    | expression '.' identifier #memberAccessExpression @Symbol(MemberAccessExpression) { Definition = bind; Type = Definition.Type; }
    | expression operator=postOperator #postExpression @Symbol(UnaryExpression) { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | operator=preOperator expression #preExpression @Symbol(UnaryExpression) { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | operator=unaryOperator expression #unaryExpression @Symbol(UnaryExpression) { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | expression 'as' typeReference #typeConversionExpression @Symbol(TypeConversionExpression) { Operator = OperatorKind.TypeAs; Type = typeReference; }
    | expression 'is' typeReference #typeConversionExpression @Symbol(TypeConversionExpression) { Operator = OperatorKind.TypeIs; Type = BuiltInType.Bool; }
    | left=expression operator=multiplicativeOperator right=expression #multiplicativeExpression @Symbol(BinaryExpression)
    | left=expression operator=additiveOperator right=expression #additiveExpression @Symbol(BinaryExpression)
    | left=expression operator=shiftOperator right=expression #shiftExpression @Symbol(BinaryExpression)
    | left=expression operator=comparisonOperator right=expression #comparisonExpression @Symbol(BinaryExpression)
    | left=expression operator=equalityOperator right=expression #equalityExpression @Symbol(BinaryExpression)
    | left=expression '&' right=expression #bitwiseAndExpression @Symbol(BinaryExpression) { Operator = OperatorKind.And; }
    | left=expression '^' right=expression #bitwiseXorExpression @Symbol(BinaryExpression) { Operator = OperatorKind.ExclusiveOr; }
    | left=expression '|' right=expression #bitwiseOrExpression @Symbol(BinaryExpression) { Operator = OperatorKind.Or; }
    | left=expression '&&' right=expression #logicalAndExpression @Symbol(BinaryExpression) { Operator = OperatorKind.AndAlso; }
    | left=expression '||' right=expression #logicalOrExpression @Symbol(BinaryExpression) { Operator = OperatorKind.OrElse; }
    | left=expression '??' right=expression #nullCoalescingExpression @Symbol(BinaryExpression) { Operator = OperatorKind.Coalesce; }
    | expression '?' then=expression ':' else=expression #conditionalExpression @Symbol(ConditionalExpression)
    | expression operator=assignmentOperator value=expression #assignmentExpression @Symbol(AssignmentExpression) 	
	;

postOperator
	: @Value(OperatorKind.PostIncrementAssign) '++'
	| @Value(OperatorKind.PostDecrementAssign) '--'
	;

preOperator
	: @Value(OperatorKind.PreIncrementAssign) '++'
	| @Value(OperatorKind.PreDecrementAssign) '--'
	;

unaryOperator
	: @Value(OperatorKind.UnaryPlus) '+'
	| @Value(OperatorKind.Negate) '-'
	| @Value(OperatorKind.OnesComplement) '~'
	| @Value(OperatorKind.Not) '!'
	;

multiplicativeOperator
	: @Value(OperatorKind.Multiply) '*'
	| @Value(OperatorKind.Divide) '/'
	| @Value(OperatorKind.Modulo) '%'
	;

additiveOperator
	: @Value(OperatorKind.Add) '+'
	| @Value(OperatorKind.Subtract) '-'
	;

shiftOperator
	: @Value(OperatorKind.LeftShift) '<<'
	| @Value(OperatorKind.RightShift) '>>'
	;

comparisonOperator
	: @Value(OperatorKind.LessThan) '<'
	| @Value(OperatorKind.GreaterThan) '>'
	| @Value(OperatorKind.LessThanOrEqual) '<='
	| @Value(OperatorKind.GreaterThanOrEqual) '>='
	;

equalityOperator
	: @Value(OperatorKind.Equal) '=='
	| @Value(OperatorKind.NotEqual) '!='
	;

assignmentOperator
	: @Value(OperatorKind.Assign) '='  
	| @Value(OperatorKind.MultiplyAssign) '*=' 
	| @Value(OperatorKind.DivideAssign) '/=' 
	| @Value(OperatorKind.ModuloAssign) '%=' 
	| @Value(OperatorKind.AddAssign) '+=' 
	| @Value(OperatorKind.SubtractAssign) '-=' 
	| @Value(OperatorKind.LeftShiftAssign) '<<='
	| @Value(OperatorKind.RightShiftAssign) '>>='
	| @Value(OperatorKind.AndAssign) '&=' 
	| @Value(OperatorKind.ExclusiveOrAssign) '^=' 
	| @Value(OperatorKind.OrAssign) '|=' 
	;
*/

associationDeclaration : KAssociation @NameUse(MetaProperty) source=qualifiedName KWith @NameUse(MetaProperty) target=qualifiedName TSemicolon
{
	source.Opposites = target;
};


// Additional rules for lexer:

// Identifiers
@Identifier
identifier : IdentifierNormal /*| IdentifierVerbatim*/;
//identifier : IdentifierGeneral | IdentifierVerbatim;

// Literals
literal 
    : nullLiteral { Type = BuiltInType.Null; Value = null; }
	| booleanLiteral { Type = BuiltInType.Bool; Value = valueof(booleanLiteral); }
	| integerLiteral { Type = BuiltInType.Int; Value = valueof(integerLiteral); }
	| decimalLiteral { Type = BuiltInType.Double; Value = valueof(decimalLiteral); }
	| scientificLiteral { Type = BuiltInType.Double; Value = valueof(scientificLiteral); }
    | stringLiteral { Type = BuiltInType.String; Value = valueof(stringLiteral); }
	;

// Null literal
nullLiteral : KNull;

// Boolean literals
booleanLiteral : KTrue | KFalse;

// Number literals
integerLiteral : IntegerLiteral;
decimalLiteral : DecimalLiteral;
scientificLiteral : ScientificLiteral;

// String literals
stringLiteral : RegularStringLiteral;


/*

 | DoubleQuoteVerbatimStringLiteral | SingleQuoteVerbatimStringLiteral

// Date and time literals  
dateOrTimeLiteral 
    : dateTimeLiteral | dateTimeOffsetLiteral | dateLiteral | timeLiteral;
dateTimeOffsetLiteral : DateTimeOffsetLiteral;
dateTimeLiteral : DateTimeLiteral;
dateLiteral : DateLiteral;
timeLiteral : TimeLiteral;

// Guid literal
guidLiteral : GuidLiteral;

@Symbol(MetaClass)
@TypeDef
classDeclaration : @Property(IsAbstract) @Value(true) KAbstract? KClass @NameDef identifier @Property(TypeParams) genericTypeParams? (TColon @Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;

genericTypeParams : LT genericTypeParam (COMMA genericTypeParam)* GT;

@Symbol(MetaTypeParam)
@TypeParam
genericTypeParam : identifier;

*/
