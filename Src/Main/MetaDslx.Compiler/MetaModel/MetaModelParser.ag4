parser grammar MetaModelParser;

options
{
    tokenVocab = MetaModelLexer; 
}

@header {
using MetaDslx.Core;
}

main: namespaceDeclaration*;

$QualifiedName
qualifiedName : identifier (TDot identifier)*;
identifierList : identifier (TComma identifier)*;
qualifiedNameList : qualifiedName (TComma qualifiedName)*;

$Symbol(MetaAnnotation)
annotation : TOpenBracket $Property(Name) identifier TCloseBracket;

/*
annotation : TOpenBracket identifier annotationParams? TCloseBracket;
annotationParams : TOpenParen annotationParamList? TCloseParen;
annotationParamList : annotationParam (TComma annotationParam)*;
annotationParam : name=identifier TAssign value=expression;
*/

$NameDef(symbolType=MetaNamespace,nestingProperty=Namespaces,merge=true)
namespaceDeclaration: annotation* KNamespace /*$Property(Name)*/ qualifiedName TAssign $Value stringLiteral TOpenBrace $Property(Models) metamodelDeclaration* TCloseBrace;

$NameDef(MetaModel)
metamodelDeclaration: annotation* KMetamodel identifier TOpenBrace declaration* TCloseBrace;

declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration;

$Property(Types) 
$TypeDef(MetaEnum)
enumDeclaration : annotation* KEnum identifier TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$NameDef(MetaEnumLiteral)
enumValue : annotation* identifier;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$Property(Types) 
$TypeDef(MetaClass)
classDeclaration : annotation* $Property(name=IsAbstract,value=true) KAbstract? KClass identifier (TColon $Property(SuperClasses) $InheritScope classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $TypeUse(MetaClass) qualifiedName;
classMemberDeclaration 
	: $Property(Properties) fieldDeclaration 
	| $Property(Operations) operationDeclaration
	| $Property(Constructor) constructorDeclaration
	;

$NameDef(MetaProperty)
fieldDeclaration : annotation* $Property(Kind) fieldModifier? $Property(Type) typeReference identifier (redefinitions | subsettings)? TSemicolon;
fieldModifier 
	: $Value(MetaPropertyKind.Containment) KContainment 
	| $Value(MetaPropertyKind.Readonly) KReadonly 
	| $Value(MetaPropertyKind.Lazy) KLazy 
	| $Value(MetaPropertyKind.Derived) KDerived
	| $Value(MetaPropertyKind.Synthetized) KSynthetized
	| $Value(MetaPropertyKind.Inherited) KInherited
	;

$Scope
redefinitions : KRedefines $Property(RedefinedProperties) nameUseList?;
$Scope
subsettings : KSubsets $Property(SubsettedProperties) nameUseList?;

nameUseList : $NameUse(MetaProperty) qualifiedName (TComma qualifiedName)*;

//$NameDef(MetaConstant)
constDeclaration : KConst typeReference /*$NameDef*/ identifier /*(TAssign expression)?*/ TSemicolon;

$TypeUse
returnType : typeReference | voidType;
$TypeUse
typeReference : collectionType | simpleType;
$TypeUse
simpleType : primitiveType | objectType | nullableType | qualifiedName;

objectType 
	: $PreDefSymbol(MetaBuiltInType.Object) KObject 
	| $PreDefSymbol(MetaBuiltInType.String) KString
	;
primitiveType 
	: $PreDefSymbol(MetaBuiltInType.Int) KInt 
	| $PreDefSymbol(MetaBuiltInType.Long) KLong 
	| $PreDefSymbol(MetaBuiltInType.Float) KFloat 
	| $PreDefSymbol(MetaBuiltInType.Double) KDouble 
	| $PreDefSymbol(MetaBuiltInType.Byte) KByte 
	| $PreDefSymbol(MetaBuiltInType.Bool) KBool
	;
voidType : $PreDefSymbol(MetaBuiltInType.Void) KVoid;

$TypeCtr(MetaNullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$TypeCtr(MetaCollectionType)
collectionType : $Property(Kind) collectionKind TLessThan $Property(InnerType) simpleType TGreaterThan;
collectionKind : $Value(MetaCollectionKind.Set) KSet | $Value(MetaCollectionKind.List) KList;

$NameDef(MetaOperation)
operationDeclaration : annotation* KStatic? $Property(ReturnType) returnType identifier TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;
parameterList : parameter (TComma parameter)*;

$NameDef(MetaParameter)
parameter : annotation* $Property(Type) typeReference identifier /*(TAssign expression)? { expression.ExpectedType = typeReference; }*/;

$NameDef(MetaConstructor)
constructorDeclaration : annotation* identifier TOpenParen TCloseParen TOpenBrace $Property(Initializers) initializerDeclaration* TCloseBrace;

initializerDeclaration 
	: synthetizedPropertyInitializer
	| inheritedPropertyInitializer
	;

$Symbol(MetaSynthetizedPropertyInitializer)
synthetizedPropertyInitializer
	: (KThis TDot)? $Property(Property) $NameUse(MetaProperty) property=identifier TAssign $Property(Value) expression TSemicolon;

$Symbol(MetaInheritedPropertyInitializer)
inheritedPropertyInitializer
	: $Property(Object) $NameUse(MetaProperty) object=identifier TDot /*$Property(Property)*/ property=identifier TAssign $Property(Value) expression TSemicolon;

argumentList 
	: expression (',' expression)*
	;

$AutoSymbol
$Expression
expression 
	: TOpenParen typeReference TCloseParen expression #castExpression $Symbol(MetaTypeConversionExpression) -> { Kind = global::MetaExpressionKind.TypeCast; }
    | KTypeof TOpenParen typeReference TCloseParen #typeofExpression $Symbol(MetaTypeOfExpression)
	| TOpenParen expression TCloseParen #bracketExpression $Symbol(MetaUnaryExpression) -> { Kind = global::MetaExpressionKind.Bracket; }
	| KThis #thisExpression $Symbol(MetaThisExpression)
	| value=literal #constantExpression $Symbol(MetaConstantExpression)
	| $Value name=identifier #identifierExpression $Symbol(MetaIdentifierExpression)
    | expression TOpenBracket $Property(Arguments) argumentList TCloseBracket #indexerExpression $Symbol(MetaIndexerExpression)
    | expression TOpenParen $Property(Arguments) argumentList? TCloseParen #functionCallExpression $Symbol(MetaFunctionCallExpression)
    | expression TDot $Value name=identifier #memberAccessExpression $Symbol(MetaMemberAccessExpression)
    | expression kind=postOperator #postExpression $Symbol(MetaUnaryExpression)
    | kind=preOperator expression #preExpression $Symbol(MetaUnaryExpression)
    | kind=unaryOperator expression #unaryExpression $Symbol(MetaUnaryExpression)
    | expression KAs typeReference #typeConversionExpression $Symbol(MetaTypeConversionExpression) -> { Kind = global::MetaExpressionKind.TypeAs; }
    | expression KIs typeReference #typeCheckExpression $Symbol(MetaTypeCheckExpression)
    | left=expression kind=multiplicativeOperator right=expression #multiplicativeExpression $Symbol(MetaBinaryArithmeticExpression)
    | left=expression kind=additiveOperator right=expression #additiveExpression $Symbol(MetaBinaryArithmeticExpression)
    | left=expression kind=shiftOperator right=expression #shiftExpression $Symbol(MetaBinaryArithmeticExpression)
    | left=expression kind=comparisonOperator right=expression #comparisonExpression $Symbol(MetaBinaryComparisonExpression)
    | left=expression kind=equalityOperator right=expression #equalityExpression $Symbol(MetaBinaryComparisonExpression)
    | left=expression TAmpersand right=expression #bitwiseAndExpression $Symbol(MetaBinaryArithmeticExpression) -> { Kind = global::MetaExpressionKind.And; }
    | left=expression THat right=expression #bitwiseXorExpression $Symbol(MetaBinaryArithmeticExpression) -> { Kind = global::MetaExpressionKind.ExclusiveOr; }
    | left=expression TBar right=expression #bitwiseOrExpression $Symbol(MetaBinaryArithmeticExpression) -> { Kind = global::MetaExpressionKind.Or; }
    | left=expression TAndAlso right=expression #logicalAndExpression $Symbol(MetaBinaryLogicalExpression) -> { Kind = global::MetaExpressionKind.AndAlso; }
    | left=expression TOrElse right=expression #logicalOrExpression $Symbol(MetaBinaryLogicalExpression) -> { Kind = global::MetaExpressionKind.OrElse; }
    | left=expression TQuestionQuestion right=expression #nullCoalescingExpression $Symbol(MetaNullCoalescingExpression)
    | condition=expression TQuestion then=expression TColon else=expression #conditionalExpression $Symbol(MetaConditionalExpression)
    | left=expression operator=assignmentOperator right=expression #assignmentExpression $Symbol(MetaAssignmentExpression)
	;

postOperator
	: $Value(MetaExpressionKind.PostIncrementAssign) TPlusPlus
	| $Value(MetaExpressionKind.PostDecrementAssign) TMinusMinus
	;

preOperator
	: $Value(MetaExpressionKind.PreIncrementAssign) TPlusPlus
	| $Value(MetaExpressionKind.PreDecrementAssign) TMinusMinus
	;

unaryOperator
	: $Value(MetaExpressionKind.UnaryPlus) TPlus
	| $Value(MetaExpressionKind.Negate) TMinus
	| $Value(MetaExpressionKind.OnesComplement) TTilde
	| $Value(MetaExpressionKind.Not) TExclamation
	;

multiplicativeOperator
	: $Value(MetaExpressionKind.Multiply) TAsterisk
	| $Value(MetaExpressionKind.Divide) TSlash
	| $Value(MetaExpressionKind.Modulo) TPercent
	;

additiveOperator
	: $Value(MetaExpressionKind.Add) TPlus
	| $Value(MetaExpressionKind.Subtract) TMinus
	;

shiftOperator
	: $Value(MetaExpressionKind.LeftShift) TLessThan TLessThan
	| $Value(MetaExpressionKind.RightShift) TGreaterThan TGreaterThan
	;

comparisonOperator
	: $Value(MetaExpressionKind.LessThan) TLessThan
	| $Value(MetaExpressionKind.GreaterThan) TGreaterThan
	| $Value(MetaExpressionKind.LessThanOrEqual) TLessThanOrEqual
	| $Value(MetaExpressionKind.GreaterThanOrEqual) TGreaterThanOrEqual
	;

equalityOperator
	: $Value(MetaExpressionKind.Equal) TEqual
	| $Value(MetaExpressionKind.NotEqual) TNotEqual
	;

assignmentOperator
	: $Value(MetaExpressionKind.Assign) TAssign  
	| $Value(MetaExpressionKind.MultiplyAssign) TAsteriskAssign 
	| $Value(MetaExpressionKind.DivideAssign) TSlashAssign
	| $Value(MetaExpressionKind.ModuloAssign) TPercentAssign
	| $Value(MetaExpressionKind.AddAssign) TPlusAssign
	| $Value(MetaExpressionKind.SubtractAssign) TMinusAssign
	| $Value(MetaExpressionKind.LeftShiftAssign) TLeftShiftAssign
	| $Value(MetaExpressionKind.RightShiftAssign) TRightShiftAssign
	| $Value(MetaExpressionKind.AndAssign) TAmpersandAssign
	| $Value(MetaExpressionKind.ExclusiveOrAssign) THatAssign
	| $Value(MetaExpressionKind.OrAssign) TBarAssign
	;


$Scope
associationDeclaration : annotation* KAssociation $NameUse(MetaProperty) source=qualifiedName KWith $NameUse(MetaProperty) target=qualifiedName TSemicolon 
	-> { source.OppositeProperties = target; }
	;


// Additional rules for lexer:

// Identifiers
$Name
$Identifier
identifier : IdentifierNormal /*| IdentifierVerbatim*/;
//identifier : IdentifierGeneral | IdentifierVerbatim;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
nullLiteral : KNull -> { this.Type = global::MetaBuiltInType.Any; this.Value = null; };

// Boolean literals
booleanLiteral : KTrue | KFalse -> { this.Type = global::MetaBuiltInType.Bool; this.Value = valueof(this); };

// Number literals
integerLiteral : IntegerLiteral -> { this.Type = global::MetaBuiltInType.Int; this.Value = valueof(this); };
decimalLiteral : DecimalLiteral -> { this.Type = global::MetaBuiltInType.Double; this.Value = valueof(this); };
scientificLiteral : ScientificLiteral -> { this.Type = global::MetaBuiltInType.Double; this.Value = valueof(this); };

// String literals
stringLiteral : RegularStringLiteral -> { this.Type = global::MetaBuiltInType.String; this.Value = valueof(this); };


/*

 | DoubleQuoteVerbatimStringLiteral | SingleQuoteVerbatimStringLiteral

// Date and time literals  
dateOrTimeLiteral 
    : dateTimeLiteral | dateTimeOffsetLiteral | dateLiteral | timeLiteral;
dateTimeOffsetLiteral : DateTimeOffsetLiteral;
dateTimeLiteral : DateTimeLiteral;
dateLiteral : DateLiteral;
timeLiteral : TimeLiteral;

// Guid literal
guidLiteral : GuidLiteral;

$Symbol(MetaClass)
$TypeDef
classDeclaration : $Property(IsAbstract) $Value(true) KAbstract? KClass $NameDef identifier $Property(TypeParams) genericTypeParams? (TColon $Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;

genericTypeParams : LT genericTypeParam (COMMA genericTypeParam)* GT;

$Symbol(MetaTypeParam)
$TypeParam
genericTypeParam : identifier;

*/
