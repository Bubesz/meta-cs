parser grammar MetaModelParser;

options
{
    tokenVocab = MetaModelLexer; 
}

@header {
using MetaDslx.Core;
}

main: namespaceDeclaration*;

$QualifiedName
qualifiedName : identifier (TDot identifier)*;
identifierList : identifier (TComma identifier)*;
qualifiedNameList : qualifiedName (TComma qualifiedName)*;

$NameDef(symbolType=MetaNamespace,nestingProperty=Namespaces,scope=true,merge=true)
namespaceDeclaration: KNamespace /*$Property(Name)*/ qualifiedName TAssign $Value stringLiteral TOpenBrace $Property(Models) metamodelDeclaration* TCloseBrace;

$TypeDef(MetaModel)
metamodelDeclaration: KMetamodel identifier TOpenBrace $Property(Types) declaration* TCloseBrace;

declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration;

$TypeDef(MetaEnum)
enumDeclaration : KEnum identifier TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$NameDef(MetaEnumLiteral)
enumValue : identifier;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$TypeDef(MetaClass)
classDeclaration : $Property(name=IsAbstract,value=true) KAbstract? KClass identifier (TColon $Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $TypeUse(MetaClass) qualifiedName;
classMemberDeclaration : $Property(Properties) fieldDeclaration | $Property(Operations) operationDeclaration;

$NameDef(MetaProperty)
fieldDeclaration : $Property(Kind) fieldModifier? $Property(Type) typeReference identifier (redefinitions | subsettings)? TSemicolon;
fieldModifier : $Value(MetaPropertyKind.Containment) KContainment | $Value(MetaPropertyKind.Readonly) KReadonly | $Value(MetaPropertyKind.Lazy) KLazy | $Value(MetaPropertyKind.Derived) KDerived;

$Scope
redefinitions : KRedefines $Property(RedefinedProperties) nameUseList?;
$Scope
subsettings : KSubsets $Property(SubsettedProperties) nameUseList?;

nameUseList : $NameUse(MetaProperty) qualifiedName (TComma qualifiedName)*;

//$NameDef(MetaConstant)
constDeclaration : KConst typeReference /*$NameDef*/ identifier /*(TAssign expression)?*/ TSemicolon;

$TypeUse
returnType : typeReference | voidType;
$TypeUse
typeReference : collectionType | simpleType;
$TypeUse
simpleType : primitiveType | objectType | nullableType | qualifiedName;

$Name
objectType 
	: $PreDefSymbol(MetaBuiltInType.Object) KObject 
	| $PreDefSymbol(MetaBuiltInType.String) KString
	;
$Name
primitiveType 
	: $PreDefSymbol(MetaBuiltInType.Int) KInt 
	| $PreDefSymbol(MetaBuiltInType.Long) KLong 
	| $PreDefSymbol(MetaBuiltInType.Float) KFloat 
	| $PreDefSymbol(MetaBuiltInType.Double) KDouble 
	| $PreDefSymbol(MetaBuiltInType.Byte) KByte 
	| $PreDefSymbol(MetaBuiltInType.Bool) KBool
	;
$Name
voidType : $PreDefSymbol(MetaBuiltInType.Void) KVoid;

$TypeCtr(MetaNullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$TypeCtr(MetaCollectionType)
collectionType : $Property(Kind) collectionKind TLessThan $Property(InnerType) simpleType TGreaterThan;
collectionKind : $Value(MetaCollectionKind.Set) KSet | $Value(MetaCollectionKind.List) KList;

$NameDef(MetaOperation)
$TypeCtr
operationDeclaration : KStatic? $Property(ReturnType) returnType identifier TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;
parameterList : parameter (TComma parameter)*;

$NameDef(MetaParameter)
parameter : $Property(Type) typeReference identifier /*(TAssign expression)? { expression.ExpectedType = typeReference; }*/;

/*
$Symbol(ArgumentList)
argumentList 
	: $Property(Arguments) expression (',' expression)*
	;

$AutoSymbol
$Expression
expression 
	: TOpenParen typeReference TCloseParen expression #castExpression $Symbol(TypeConversionExpression) -> { Operator = global::MetaOperatorKind.TypeCast; Type = typeReference; }
    | KTypeof TOpenParen typeReference TCloseParen #typeofExpression -> { Type = typeof(global::MetaType); }
	| TOpenParen expression TCloseParen #bracketExpression -> { Type = expression.Type; expression.ExpectedType = ExpectedType; }
	| literal #constantExpression -> { literal.ExpectedType = ExpectedType; }
	| identifier #identifierExpression $NameUse -> { identifier.ExpectedType = ExpectedType; Type = identifier.Type; }
    | expression TOpenBracket argumentList TCloseBracket #indexerExpression -> { Definition = bind(expression,argumentList); Type = Definition.ReturnType; argumentList.ExpectedTypes = Definition.ExpectedTypes; }
    | expression TOpenParen argumentList? TCloseParen #functionCallExpression -> { Definition = bind(expression,argumentList); Type = Definition.ReturnType; argumentList.ExpectedTypes = Definition.ExpectedTypes; }
    | expression TDot identifier #memberAccessExpression -> { Definition = bind(expression,identifier); Type = Definition.Type; }
    | expression operator=postOperator #postExpression $Symbol(UnaryExpression) -> { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | operator=preOperator expression #preExpression $Symbol(UnaryExpression) -> { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | operator=unaryOperator expression #unaryExpression $Symbol(UnaryExpression) -> { Type = expression.Type; expression.ExpectedType = ExpectedType; }
    | expression KAs typeReference #typeConversionExpression $Symbol(TypeConversionExpression) -> { Operator = global::MetaOperatorKind.TypeAs; Type = typeReference; }
    | expression KIs typeReference #typeCheckExpression $Symbol(TypeConversionExpression) -> { Operator = global::MetaOperatorKind.TypeIs; Type = global::MetaBuiltInType.Bool; }
    | left=expression operator=multiplicativeOperator right=expression #multiplicativeExpression $Symbol(BinaryExpression) -> { BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression operator=additiveOperator right=expression #additiveExpression $Symbol(BinaryExpression) -> { BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression operator=shiftOperator right=expression #shiftExpression $Symbol(BinaryExpression) -> { BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression operator=comparisonOperator right=expression #comparisonExpression $Symbol(BinaryExpression) -> { BalancedType=balance(left,right); Type=global::MetaBuiltInType.Bool; left.ExpectedType=BalancedType; right.ExpectedType=BalancedType; }
    | left=expression operator=equalityOperator right=expression #equalityExpression $Symbol(BinaryExpression) -> { BalancedType=balance(left,right); Type=global::MetaBuiltInType.Bool; left.ExpectedType=BalancedType; right.ExpectedType=BalancedType; }
    | left=expression TAmpersand right=expression #bitwiseAndExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.And; BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression THat right=expression #bitwiseXorExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.ExclusiveOr; BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression TBar right=expression #bitwiseOrExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.Or; BalancedType=balance(left,right); Type=BalancedType; left.ExpectedType = ExpectedType; right.ExpectedType = ExpectedType; }
    | left=expression TAndAlso right=expression #logicalAndExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.AndAlso; Type=global::MetaBuiltInType.Bool; left.ExpectedType=global::MetaBuiltInType.Bool; right.ExpectedType=global::MetaBuiltInType.Bool; }
    | left=expression TOrElse right=expression #logicalOrExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.OrElse; Type=global::MetaBuiltInType.Bool; left.ExpectedType=global::MetaBuiltInType.Bool; right.ExpectedType=global::MetaBuiltInType.Bool; }
    //| left=expression '??' right=expression #nullCoalescingExpression $Symbol(BinaryExpression) -> { Operator = global::MetaOperatorKind.Coalesce; }
    | condition=expression TQuestion then=expression TColon else=expression #conditionalExpression $Symbol(ConditionalExpression) -> { Type = balance(then,else); condition.ExpectedType = global::MetaBuiltInType.Bool; then.ExpectedType = ExpectedType; else.ExpectedType = ExpectedType; }
    //| expression operator=assignmentOperator value=expression #assignmentExpression $Symbol(BinaryExpression) 	
	;

postOperator
	: $Value(MetaOperatorKind.PostIncrementAssign) TPlusPlus
	| $Value(MetaOperatorKind.PostDecrementAssign) TMinusMinus
	;

preOperator
	: $Value(MetaOperatorKind.PreIncrementAssign) TPlusPlus
	| $Value(MetaOperatorKind.PreDecrementAssign) TMinusMinus
	;

unaryOperator
	: $Value(MetaOperatorKind.UnaryPlus) TPlus
	| $Value(MetaOperatorKind.Negate) TMinus
	| $Value(MetaOperatorKind.OnesComplement) TTilde
	| $Value(MetaOperatorKind.Not) TExclamation
	;

multiplicativeOperator
	: $Value(MetaOperatorKind.Multiply) TAsterisk
	| $Value(MetaOperatorKind.Divide) TSlash
	| $Value(MetaOperatorKind.Modulo) TPercent
	;

additiveOperator
	: $Value(MetaOperatorKind.Add) TPlus
	| $Value(MetaOperatorKind.Subtract) TMinus
	;

shiftOperator
	: $Value(MetaOperatorKind.LeftShift) TLessThan TLessThan
	| $Value(MetaOperatorKind.RightShift) TGreaterThan TGreaterThan
	;

comparisonOperator
	: $Value(MetaOperatorKind.LessThan) TLessThan
	| $Value(MetaOperatorKind.GreaterThan) TGreaterThan
	| $Value(MetaOperatorKind.LessThanOrEqual) TLessThanOrEqual
	| $Value(MetaOperatorKind.GreaterThanOrEqual) TGreaterThanOrEqual
	;

equalityOperator
	: $Value(MetaOperatorKind.Equal) TEqual
	| $Value(MetaOperatorKind.NotEqual) TNotEqual
	;

assignmentOperator
	: $Value(MetaOperatorKind.Assign) TAssign  
	| $Value(MetaOperatorKind.MultiplyAssign) TAsteriskAssign 
	| $Value(MetaOperatorKind.DivideAssign) TSlashAssign
	| $Value(MetaOperatorKind.ModuloAssign) TPercentAssign
	| $Value(MetaOperatorKind.AddAssign) TPlusAssign
	| $Value(MetaOperatorKind.SubtractAssign) TMinusAssign
	| $Value(MetaOperatorKind.LeftShiftAssign) TLeftShiftAssign
	| $Value(MetaOperatorKind.RightShiftAssign) TRightShiftAssign
	| $Value(MetaOperatorKind.AndAssign) TAmpersandAssign
	| $Value(MetaOperatorKind.ExclusiveOrAssign) THatAssign
	| $Value(MetaOperatorKind.OrAssign) TBarAssign
	;
*/


$Scope
associationDeclaration : KAssociation $NameUse(MetaProperty) source=qualifiedName KWith $NameUse(MetaProperty) target=qualifiedName TSemicolon 
	-> { source.OppositeProperties = target; }
	;


// Additional rules for lexer:

// Identifiers
$Name
$Identifier
identifier : IdentifierNormal /*| IdentifierVerbatim*/;
//identifier : IdentifierGeneral | IdentifierVerbatim;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
nullLiteral : KNull -> { this.Type = global::MetaBuiltInType.Any; this.Value = null; };

// Boolean literals
booleanLiteral : KTrue | KFalse -> { this.Type = global::MetaBuiltInType.Bool; this.Value = valueof(this); };

// Number literals
integerLiteral : IntegerLiteral -> { this.Type = global::MetaBuiltInType.Int; this.Value = valueof(this); };
decimalLiteral : DecimalLiteral -> { this.Type = global::MetaBuiltInType.Double; this.Value = valueof(this); };
scientificLiteral : ScientificLiteral -> { this.Type = global::MetaBuiltInType.Double; this.Value = valueof(this); };

// String literals
stringLiteral : RegularStringLiteral -> { this.Type = global::MetaBuiltInType.String; this.Value = valueof(this); };


/*

 | DoubleQuoteVerbatimStringLiteral | SingleQuoteVerbatimStringLiteral

// Date and time literals  
dateOrTimeLiteral 
    : dateTimeLiteral | dateTimeOffsetLiteral | dateLiteral | timeLiteral;
dateTimeOffsetLiteral : DateTimeOffsetLiteral;
dateTimeLiteral : DateTimeLiteral;
dateLiteral : DateLiteral;
timeLiteral : TimeLiteral;

// Guid literal
guidLiteral : GuidLiteral;

$Symbol(MetaClass)
$TypeDef
classDeclaration : $Property(IsAbstract) $Value(true) KAbstract? KClass $NameDef identifier $Property(TypeParams) genericTypeParams? (TColon $Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;

genericTypeParams : LT genericTypeParam (COMMA genericTypeParam)* GT;

$Symbol(MetaTypeParam)
$TypeParam
genericTypeParam : identifier;

*/
