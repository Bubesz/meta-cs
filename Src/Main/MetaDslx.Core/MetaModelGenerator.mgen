namespace MetaDslx.Core;
generator MetaModelGenerator for IEnumerable<MetaModel>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
	[loop(mm:Instances)]
[GenerateMetamodel(mm)]
	[end loop]
end template

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName()]
{
	[loop(model->Types->enm:typeof(MetaEnum))]
    [GenerateEnum(enm)]
	[end loop]
	[loop(model->Types->cls:typeof(MetaClass))]
    [GenerateInterface(cls)]
    [GenerateInterfaceImpl(model, cls)]
	[end loop]
    [GenerateFactory(model)]
    [GenerateImplementationProvider(model)]
}
end template

template GenerateEnum(MetaEnum enm)
public enum [enm.CSharpName()]
{
    [loop(enm->value:EnumLiterals)]
    [value.Name],
	[end loop]
}
^
end template

function string GetAncestors(MetaClass cls)
	string result = "";
	loop(cls->super:SuperClasses; string delim = " : "; delim = ", ")
		result += delim+super.Namespace.CSharpName()+"."+super.CSharpName();
	end loop
	return result;
end function

template GenerateInterface(MetaClass cls)
public interface [cls.CSharpName()][GetAncestors(cls)]
{
    [loop(cls->prop:Properties)]
    [GenerateProperty(prop)]
	[end loop]
^
    [loop(cls->op:Operations)]
    [GenerateOperation(op)]
	[end loop]
}
^
end template

template GenerateProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
[prop.Type.CSharpPublicName()] [prop.Name] { get; set; }
	[else]
[prop.Type.CSharpPublicName()] [prop.Name] { get; }
	[end if]
end template

function string GetParameters(MetaOperation op, bool defaultValues)
	string result = "";
	loop(op->param:Parameters; string delim = ""; delim = ", ")
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
/*		if (defaultValues && param.DefaultValue != null)
			result += " = "+param.DefaultValue;
		end if*/
	end loop
	return result;
end function

function string GetImplParameters(MetaClass cls, MetaOperation op)
	string result = cls.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaEnum enm, MetaOperation op)
	string result = enm.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplParameters(MetaEnum enm, MetaOperation op)
	string result = "this "+enm.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplCallParameterNames(MetaOperation op)
	string result = "@this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

function string GetImplCallParameterNames(MetaOperation op)
	string result = "this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

template GenerateOperation(MetaOperation op)
[op.ReturnType.CSharpPublicName()] [op.Name]([GetParameters(op, true)]);
end template

template GenerateInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName()] : ModelObject, [cls.Namespace.CSharpName()].[cls.CSharpName()]
{
[if (hasloop(cls->sup:GetAllSuperClasses(false)))]
    static [cls.CSharpImplName()]()
    {
		[loop(cls->sup:GetAllSuperClasses(false))]
		ModelProperty.RegisterAncestor(typeof([cls.CSharpImplName()]), typeof([sup.CSharpImplName()]));
		[end loop]
    }
^
[end if]
    [GenerateConstructorImpl(model, cls)]
    [loop(cls->prop:GetAllProperties())]
    [GeneratePropertyImpl(model, cls, prop)]
	[end loop]
    [loop(cls->op:GetAllOperations())]
    [GenerateOperationImpl(model, op)]
	[end loop]
}
^
end template

template GeneratePropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if(prop.Class == cls)]
[if(prop.Kind == MetaPropertyKind.Containment)]
["[ContainmentAttribute]"]
[end if]
[if(prop.Kind != MetaPropertyKind.Normal && prop.Kind != MetaPropertyKind.Containment && !(prop.Type is MetaCollectionType))]
["[ReadonlyAttribute]"]
[end if]
[loop(p:prop.OppositeProperties)]
["[OppositeAttribute(typeof("][p.Class.CSharpImplName()]["), \""][p.Name]["\")]"]
[end if]
[loop(p:prop.SubsettedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[SubsetsAttribute(typeof("][p.Class.CSharpImplName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: subsetted property '[p.Class.CSharpImplName()].[p.Name]' must be a property of an ancestor class
	[end if]
[end if]
[loop(p:prop.RedefinedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[RedefinesAttribute(typeof("][p.Class.CSharpImplName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: redefined property '[p.Class.CSharpImplName()].[p.Name]' must be a property of an ancestor class
	[end if]
[end if]
internal static readonly ModelProperty [prop.Name]Property =
    ModelProperty.Register("[prop.Name]", typeof([prop.Type.CSharpPublicName()]), typeof([prop.Class.CSharpImplName()]));
[end if]
[prop.Type.CSharpPublicName()] [prop.Class.CSharpName()].[prop.Name]
{
	[if(prop.Kind == MetaPropertyKind.Derived)]
    get { return [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this); }
	[else]
    get { return ([prop.Type.CSharpPublicName()])this.MGetValue([prop.Class.CSharpImplName()].[prop.Name]Property); }
	[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
    set { this.MSetValue([prop.Class.CSharpImplName()].[prop.Name]Property, value); }
	[end if]
}
end template

function string GetCollectionConstructorParams(MetaProperty prop)
	MetaCollectionType mct = prop.Type as MetaCollectionType;
	if(mct != null && mct.InnerType is MetaClass)
		return "this, " + prop.Class.CSharpImplName() + "." + prop.Name + "Property";
	else
		return "";
	end if
end function

template GenerateConstructorImpl(MetaModel model, MetaClass cls)
public [cls.CSharpImplName()]()
{
	[loop(cls->prop:GetAllProperties())]
		[if(prop.Type is MetaCollectionType)]
			[if (prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment)]
    this.MSetValue([prop.Class.CSharpImplName()].[prop.Name]Property, new [prop.Type.CSharpName()]([GetCollectionConstructorParams(prop)]));
			[else if (prop.Kind == MetaPropertyKind.Lazy)]
    this.MInitValue([prop.Class.CSharpImplName()].[prop.Name]Property, new Lazy<object>(() => [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this)));
			[else if (prop.Kind == MetaPropertyKind.Readonly)]
    // Init [prop.Class.CSharpImplName()].[prop.Name]Property in [model.CSharpName()]Implementation.[cls.CSharpName()]_[cls.CSharpName()]
			[end if]
	    [else]
			[if(prop.Kind == MetaPropertyKind.Lazy)]
    this.MInitValue([prop.Class.CSharpImplName()].[prop.Name]Property, new Lazy<object>(() => [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this)));
			[else if (prop.Kind == MetaPropertyKind.Readonly)]
    // Init [prop.Class.CSharpImplName()].[prop.Name]Property in [model.CSharpName()]Implementation.[cls.CSharpName()]_[cls.CSharpName()]
			[end if]
		[end if]
	[end loop]
    [cls.Model.CSharpName()]ImplementationProvider.Implementation.[cls.CSharpName()]_[cls.CSharpName()](this);
    [loop(cls->prop:GetAllProperties())]
		[if (prop.Kind == MetaPropertyKind.Readonly)]
    if (!this.MIsSet([prop.Class.CSharpImplName()].[prop.Name]Property)) throw new ModelException("Readonly property [prop.Class.CSharpImplName()].[prop.Name]Property was not set in [cls.CSharpName()]_[cls.CSharpName()]().");
		[end if]
	[end loop]
    this.MMakeDefault();
}
end template

function string GetReturn(MetaOperation op)
    if (op.ReturnType.CSharpName() == "void") 
		return "";
	else 
		return "return ";
	end if
end function

template GenerateOperationImpl(MetaModel model, MetaOperation op)
^
[op.ReturnType.CSharpPublicName()] [op.Parent.CSharpName()].[op.Name]([GetParameters(op, false)])
{
    [GetReturn(op)][model.CSharpName()]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetImplCallParameterNames(op)]);
}
end template

function string GetSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:SuperClasses; string delim = ""; delim = ", ")
		result += delim+sup.CSharpName();
	end loop
	return result;
end function

function string GetAllSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:GetAllSuperClasses(false); string delim = ""; delim = ", ")
		result += delim+sup.CSharpName();
	end loop
	return result;
end function

template GenerateImplementationProvider(MetaModel model)
internal static class [model.Name]ImplementationProvider
{
    // If there is a compile error at this line, create a new class called [model.Name]Implementation
	// which is a subclass of [model.Name]ImplementationBase:
    private static [model.Name]Implementation implementation = new [model.Name]Implementation();
^
    public static [model.Name]Implementation Implementation
    {
        get { return [model.Name]ImplementationProvider.implementation; }
    }
}
	[loop(model->Types->enm:typeof(MetaEnum))]
^
public static class [model.Name][enm.Name]Extensions
{
    [loop(enm->op:Operations)]
    public static [op.ReturnType.CSharpPublicName()] [op.Name]([GetEnumImplParameters(enm, op)])
    {
        [GetReturn(op)][model.CSharpName()]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetEnumImplCallParameterNames(op)]);
    }
	[end loop]
}
	[end loop]
^
/// <summary>
/// Base class for implementing the behavior of the model elements.
/// This class has to be be overriden in [model.Name]Implementation to provide custom
/// implementation for the constructors, operations and property values.
/// </summary>
internal abstract class [model.Name]ImplementationBase
{
	[string delim = ""]
	[loop(model->Types->cls:typeof(MetaClass))]
    /// <summary>
	/// Implements the constructor: [cls.CSharpName()]()
	[if (hasloop(cls->sup:SuperClasses))]
	/// Direct superclasses: [GetSuperClasses(cls)]
	/// All superclasses: [GetAllSuperClasses(cls)]
	[end if]
	[if (hasloop(cls->prop:GetAllProperties() where prop.Kind == MetaPropertyKind.Readonly))]
    // Initializes the following readonly properties:
	[end if]
    [loop(cls->prop:GetAllProperties())]
	[if (prop.Kind == MetaPropertyKind.Readonly)]
    ///    [prop.Class.Name].[prop.Name]
	[end if]
	[end loop]
    /// </summary>
    public virtual void [cls.CSharpName()]_[cls.CSharpName()]([cls.CSharpName()] @this)
    {
    }
    [loop(cls->prop:Properties)]
	[if (prop.Kind == MetaPropertyKind.Derived)]
^
    /// <summary>
    /// Returns the value of the derived property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
	[else if (prop.Kind == MetaPropertyKind.Lazy)]
^
    /// <summary>
    /// Returns the value of the lazy property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
	[end if]
	[end loop]
    [loop(cls->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [cls.CSharpName()].[op.Name]()
    /// </summary>
    public virtual [op.ReturnType.CSharpPublicName()] [cls.CSharpName()]_[op.Name]([GetImplParameters(cls, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
	[loop(model->Types->enm:typeof(MetaEnum))]
    [loop(enm->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [enm.CSharpName()].[op.Name]
    /// </summary>
    public virtual [op.ReturnType.CSharpPublicName()] [enm.CSharpName()]_[op.Name]([GetImplParameters(enm, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
}
^
end template

template GenerateFactory(MetaModel model)
/// <summary>
/// Factory class for creating instances of model elements.
/// </summary>
public class [model.Name]Factory : ModelFactory
{
    private static [model.Name]Factory instance = new [model.Name]Factory();
^
	private [model.Name]Factory()
	{
	}
^
    /// <summary>
    /// The singleton instance of the factory.
    /// </summary>
    public static [model.Name]Factory Instance
    {
        get { return [model.Name]Factory.instance; }
    }
	[loop(model->Types->cls:typeof(MetaClass))]
^
    /// <summary>
    /// Creates a new instance of [cls.CSharpName()].
    /// </summary>
    public [cls.CSharpName()] Create[cls.CSharpName()]()
	{
		[cls.CSharpName()] result = new [cls.CSharpImplName()]();
		return result;
	}
^
	[end loop]
}
^
end template
