namespace MetaDslx.Core;
generator MetaModelGenerator for IEnumerable<MetaModel>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
	[loop(mm:Instances)]
[GenerateMetamodel(mm)]
	[end loop]
end template

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName()]
{
    [GenerateMetaModel(model)]
	[loop(model->Types->enm:typeof(MetaEnum))]
    [GenerateEnum(enm)]
	[end loop]
	[loop(model->Types->cls:typeof(MetaClass))]
    [GenerateInterface(cls)]
    [GenerateInterfaceImpl(model, cls)]
	[end loop]
    [GenerateFactory(model)]
    [GenerateImplementationProvider(model)]
}
end template

template GenerateAnnotations(MetaAnnotatedElement elem)
[loop(elem->annot:Annotations)]
["["][annot.Name]["]"]
[end loop]
end template

template GenerateEnum(MetaEnum enm)
[GenerateAnnotations(enm)]
public enum [enm.CSharpName()]
{
    [loop(enm->value:EnumLiterals)]
    [value.Name],
	[end loop]
}
^
end template

function string GetAncestors(MetaClass cls)
	string result = "";
	loop(cls->super:SuperClasses; string delim = " : "; delim = ", ")
		result += delim+super.Namespace.CSharpName()+"."+super.CSharpName();
	end loop
	return result;
end function

template GenerateInterface(MetaClass cls)
[GenerateAnnotations(cls)]
public interface [cls.CSharpName()][GetAncestors(cls)]
{
    [loop(cls->prop:Properties)]
    [GenerateProperty(prop)]
	[end loop]
^
    [loop(cls->op:Operations)]
    [GenerateOperation(op)]
	[end loop]
}
^
end template

template GenerateProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
[prop.Type.CSharpPublicName()] [prop.Name] { get; set; }
	[else]
[prop.Type.CSharpPublicName()] [prop.Name] { get; }
	[end if]
end template

function string GetParameters(MetaOperation op, bool defaultValues)
	string result = "";
	loop(op->param:Parameters; string delim = ""; delim = ", ")
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
/*		if (defaultValues && param.DefaultValue != null)
			result += " = "+param.DefaultValue;
		end if*/
	end loop
	return result;
end function

function string GetImplParameters(MetaClass cls, MetaOperation op)
	string result = cls.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaEnum enm, MetaOperation op)
	string result = enm.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplParameters(MetaEnum enm, MetaOperation op)
	string result = "this "+enm.CSharpName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpPublicName()+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplCallParameterNames(MetaOperation op)
	string result = "@this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

function string GetImplCallParameterNames(MetaOperation op)
	string result = "this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

template GenerateOperation(MetaOperation op)
[op.ReturnType.CSharpPublicName()] [op.Name]([GetParameters(op, true)]);
end template

template GenerateInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName()] : ModelObject, [cls.Namespace.CSharpName()].[cls.CSharpName()]
{
    static [cls.CSharpImplName()]()
    {
        [model.CSharpFullName()].StaticInit();
    }
^
    [GenerateConstructorImpl(model, cls)]
    [loop(cls->prop:GetAllProperties())]
    [GeneratePropertyImpl(model, cls, prop)]
	[end loop]
    [loop(cls->op:GetAllOperations())]
    [GenerateOperationImpl(model, op)]
	[end loop]
}
^
end template

template GeneratePropertyDeclaration(MetaModel model, MetaClass cls, MetaProperty prop)
[if(prop.Class == cls)]
[GenerateAnnotations(prop)]
[if(prop.Kind == MetaPropertyKind.Containment)]
["[ContainmentAttribute]"]
[end if]
[if(prop.Kind != MetaPropertyKind.Normal && prop.Kind != MetaPropertyKind.Containment && !(prop.Type is MetaCollectionType))]
["[ReadonlyAttribute]"]
[end if]
[loop(p:prop.OppositeProperties)]
["[OppositeAttribute(typeof("][p.Class.Model.CSharpFullName()].[p.Class.CSharpName()]["), \""][p.Name]["\")]"]
[end if]
[loop(p:prop.SubsettedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[SubsetsAttribute(typeof("][p.Class.Model.CSharpFullName()].[p.Class.CSharpName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: subsetted property '[p.Class.Model.CSharpFullName()].[p.Class.CSharpName()].[p.Name]' must be a property of an ancestor class
	[end if]
[end if]
[loop(p:prop.RedefinedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[RedefinesAttribute(typeof("][p.Class.Model.CSharpFullName()].[p.Class.CSharpName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: redefined property '[p.Class.Model.CSharpFullName()].[p.Class.CSharpName()].[p.Name]' must be a property of an ancestor class
	[end if]
[end if]
public static readonly ModelProperty [prop.Name]Property =
    ModelProperty.Register("[prop.Name]", typeof([prop.Type.CSharpFullPublicName()]), typeof([prop.Class.CSharpFullName()]), typeof([prop.Class.Model.CSharpFullName()].[prop.Class.CSharpName()]));
[end if]
^
end template

template GeneratePropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[prop.Type.CSharpPublicName()] [prop.Class.CSharpName()].[prop.Name]
{
	[if(prop.Kind == MetaPropertyKind.Derived)]
		[MetaSynthetizedPropertyInitializer synInit = GetSynthetizedInitializerFor(cls, prop)]
		[if (synInit == null)]
    get { return [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this); }
		[else]
    get { return [GenerateExpression(synInit.Value)]; }
		[end if]
	[else]
    get 
    {
        object result = this.MGet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property); 
        if (result != null) return ([prop.Type.CSharpPublicName()])result;
        else return default([prop.Type.CSharpPublicName()]);
    }
	[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
    set { this.MSet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, value); }
	[end if]
}
end template

function string GetCollectionConstructorParams(MetaProperty prop)
	MetaCollectionType mct = prop.Type as MetaCollectionType;
	if(mct != null && mct.InnerType is MetaClass)
		return "this, " + prop.Class.Model.CSharpFullName() + "." + prop.Class.CSharpName() + "." + prop.Name + "Property";
	else
		return "";
	end if
end function

template GenerateConstantValueExpression(string name, MetaExpression expr, string nameType)
[switch (expr)]
[type as MetaNewExpression:]
[string tmpName = "tmp"+NextCounter()]
[string tmpType = expr.TypeReference.CSharpFullName()]
[tmpType] [tmpName] = [expr.TypeReference.Model.Name]Factory.Instance.Create[expr.TypeReference.CSharpName()]();
[if (nameType != null)]
[nameType] \
[end if]
[name] = [tmpName];
[loop (expr->pi:PropertyInitializers)]
[GenerateConstantValueExpression(tmpName+"."+pi.PropertyName, pi.Value, null)]
[end loop]
[type as MetaNewCollectionExpression:]
[loop (expr->v:Values)]
[string tmpName = "tmp"+NextCounter()]
[string tmpType = v.Type.CSharpFullName()]
	[if (v is MetaNewExpression)]
[GenerateConstantValueExpression(tmpName, v, tmpType)]
[name].Add([tmpName]);
	[else if (v is MetaNewCollectionExpression)]
// TODO
	[else]
[name].Add([GenerateExpression(expr)]);
	[end if]
[end loop]
[default:][name] = [GenerateExpression(expr)];
[end switch]
end template

template GenerateNewObject()
end template

template GenerateExpression(MetaExpression expr)
[switch (expr)]
[type as MetaBracketExpression:]([GenerateExpression(expr.Expression)])\
[type as MetaThisExpression:](([((MetaType)ModelContext.Current.Compiler.ResolutionProvider.GetCurrentTypeScopeOf((ModelObject)expr)).CSharpName()])this)\
[type as MetaNullExpression:]null\
[type as MetaTypeAsExpression:][GenerateExpression(expr.Expression)] as [expr.TypeReference.CSharpName()]\
[type as MetaTypeCastExpression:]([expr.TypeReference.CSharpName()])[GenerateExpression(expr.Expression)]\
[type as MetaTypeCheckExpression:][GenerateExpression(expr.Expression)] is [expr.TypeReference.CSharpName()]\
[type as MetaTypeOfExpression:][GenerateTypeOf(expr)]\
[type as MetaConditionalExpression:][GenerateExpression(expr.Condition)] ? [GenerateExpression(expr.Then)] : [GenerateExpression(expr.Else)]\
[type as MetaConstantExpression:][GetCSharpValue(expr.Value)]\
[type as MetaIdentifierExpression:][GenerateIdentifierExpression(expr)]\
[type as MetaMemberAccessExpression:][GenerateExpression(expr.Expression)].[expr.Name]\
[type as MetaFunctionCallExpression:][GenerateFunctionCall(expr)]\
[type as MetaIndexerExpression:][GenerateIndexerCall(expr)]\
[type as MetaOperatorExpression:][GenerateOperator(expr)]\
[default:]***unknown expression type***
[end switch]
end template

template GenerateIdentifierExpression(MetaIdentifierExpression expr)
[if (expr.Definition is MetaProperty)]
(([((MetaType)ModelContext.Current.Compiler.ResolutionProvider.GetCurrentTypeScopeOf((ModelObject)expr)).CSharpName()])this).[expr.Name]\
[else]
[expr.Name]\
[end if]
end template

template GenerateFunctionCall(MetaFunctionCallExpression call)
[switch(call.Definition)]
[case Meta.Constants.TypeOf:][GenerateTypeOf(call.Arguments[0])]\
[case Meta.Constants.GetValueType:]ModelContext.Current.Compiler.TypeProvider.GetTypeOf([GenerateCallArguments(call, "")])\
[case Meta.Constants.GetReturnType:]ModelContext.Current.Compiler.TypeProvider.GetReturnTypeOf([GenerateCallArguments(call, "(ModelObject)")])\
[case Meta.Constants.CurrentType:]ModelContext.Current.Compiler.ResolutionProvider.GetCurrentTypeScopeOf([GenerateCallArguments(call, "(ModelObject)")])\
[case Meta.Constants.TypeCheck:]ModelContext.Current.Compiler.TypeProvider.TypeCheck([GenerateCallArguments(call, "(ModelObject)")])\
[case Meta.Constants.Balance:]ModelContext.Current.Compiler.TypeProvider.Balance([GenerateCallArguments(call, "(ModelObject)")])\
[case Meta.Constants.Resolve1:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { ModelContext.Current.Compiler.ResolutionProvider.GetCurrentScope(this) }, ResolveKind.NameOrType, [GenerateExpression(call.Arguments[0])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.Resolve2:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { (ModelObject)[GenerateExpression(call.Arguments[0])] }, ResolveKind.NameOrType, [GenerateExpression(call.Arguments[1])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.ResolveType1:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { ModelContext.Current.Compiler.ResolutionProvider.GetCurrentScope(this) }, ResolveKind.Type, [GenerateExpression(call.Arguments[0])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.ResolveType2:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { (ModelObject)[GenerateExpression(call.Arguments[0])] }, ResolveKind.Type, [GenerateExpression(call.Arguments[1])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.ResolveName1:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { ModelContext.Current.Compiler.ResolutionProvider.GetCurrentScope(this) }, ResolveKind.Name, [GenerateExpression(call.Arguments[0])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.ResolveName2:]ModelContext.Current.Compiler.ResolutionProvider.Resolve(new ModelObject["[]"] { (ModelObject)[GenerateExpression(call.Arguments[0])] }, ResolveKind.Name, [GenerateExpression(call.Arguments[1])], new ResolutionInfo(), ResolveFlags.All)\
[case Meta.Constants.Bind1:]ModelContext.Current.Compiler.BindingProvider.Bind(this, new ModelObject["[]"] { (ModelObject)[GenerateExpression(call.Arguments[0])] }, new BindingInfo())\
[case Meta.Constants.Bind2:]ModelContext.Current.Compiler.BindingProvider.Bind(this, [GenerateExpression(call.Arguments[0])], new BindingInfo())\
[case Meta.Constants.Bind3:]ModelContext.Current.Compiler.BindingProvider.Bind((ModelObject)[GenerateExpression(call.Arguments[0])], new ModelObject["[]"] { (ModelObject)[GenerateExpression(call.Arguments[1])] }, new BindingInfo())\
[case Meta.Constants.Bind4:]ModelContext.Current.Compiler.BindingProvider.Bind((ModelObject)[GenerateExpression(call.Arguments[0])], [GenerateExpression(call.Arguments[1])], new BindingInfo())\
[case Meta.Constants.SelectOfType1:]new object["[]"] { [GenerateExpression(call.Arguments[0])] }.Where(e => ModelContext.Current.Compiler.TypeProvider.GetTypeOf(e) is [GetTypeName(call.Arguments[1])]).OfType<ModelObject>().ToList()\
[case Meta.Constants.SelectOfType2:]([GenerateExpression(call.Arguments[0])]).Where(e => ModelContext.Current.Compiler.TypeProvider.GetTypeOf(e) is [GetTypeName(call.Arguments[1])]).OfType<ModelObject>().ToList()\
[case Meta.Constants.SelectOfName1:]new object["[]"] { [GenerateExpression(call.Arguments[0])] }.Where(e => ModelContext.Current.Compiler.NameProvider.GetNameOf((ModelObject)e) == [GenerateExpression(call.Arguments[1])]).OfType<ModelObject>().ToList()\
[case Meta.Constants.SelectOfName2:]([GenerateExpression(call.Arguments[0])]).Where(e => ModelContext.Current.Compiler.NameProvider.GetNameOf((ModelObject)e) == [GenerateExpression(call.Arguments[1])]).OfType<ModelObject>().ToList()\
[default:][GenerateExpression(call.Expression)]([GenerateCallArguments(call, "")])\
[end switch]
end template

template GenerateIndexerCall(MetaIndexerExpression call)
[GenerateExpression(call.Expression)]["["][GenerateCallArguments(call, "")]["]"]\
end template

template GenerateTypeOf(object expr)
[switch(expr)]
[case Meta.Constants.None:]Meta.Constants.None\
[case Meta.Constants.Error:]Meta.Constants.Error\
[case Meta.Constants.Any:]Meta.Constants.Any\
[case Meta.Constants.Object:]Meta.Constants.Object\
[case Meta.Constants.String:]Meta.Constants.String\
[case Meta.Constants.Int:]Meta.Constants.Int\
[case Meta.Constants.Long:]Meta.Constants.Long\
[case Meta.Constants.Float:]Meta.Constants.Float\
[case Meta.Constants.Double:]Meta.Constants.Double\
[case Meta.Constants.Byte:]Meta.Constants.Byte\
[case Meta.Constants.Bool:]Meta.Constants.Bool\
[case Meta.Constants.Void:]Meta.Constants.Void\
[case Meta.Constants.ModelObject:]Meta.Constants.ModelObject\
[case Meta.Constants.ModelObjectList:]Meta.Constants.ModelObjectList\
[type as MetaTypeOfExpression:][GenerateTypeOf(expr.TypeReference)]\
[type as MetaClass:]global::MetaDslx.Core.[expr.Model.CSharpName()].[expr.CSharpName()].Instance\
[type as MetaCollectionType:][expr.CSharpFullName()]\
[default:]***error***\
[end switch]
end template

template GenerateCallArguments(MetaBoundExpression call, string prefix)
[loop(call->arg:Arguments; string delim = ""; delim = ", ")]
[delim][prefix][GenerateExpression(arg)]\
[end loop]
end template

template GenerateOperator(MetaOperatorExpression expr)
[switch (expr)]
[type as MetaUnaryExpression:]
	[if (expr is MetaPostIncrementAssignExpression || expr is MetaPostDecrementAssignExpression)]
[GenerateExpression(expr.Expression)][GetCSharpOperator(expr)]\
	[else]
[GetCSharpOperator(expr)][GenerateExpression(expr.Expression)]\
	[end if]
[type as MetaBinaryExpression:]
[GenerateExpression(expr.Left)][GetCSharpOperator(expr)][GenerateExpression(expr.Right)]\
[end switch]
end template

template GenerateNewPropertyInitializers(MetaNewExpression expr)
[loop(expr->pi:PropertyInitializers; string delim = ""; delim = ", ")]
[delim][pi.Property.Name] = [GenerateExpression(pi.Value)]\
[end loop]
end template

template GenerateNewCollectionInitializers(MetaNewCollectionExpression expr)
[loop(expr->v:Values; string delim = ""; delim = ", ")]
[delim][GenerateExpression(v)]\
[end loop]
end template

function string GetCSharpValue(object value)
	if (value == null) return "null";
	else if (value is bool && ((bool)value) == true) return "true";
	else if (value is bool && ((bool)value) == false) return "false";
	else if (value is MetaExpression) return GenerateExpression((MetaExpression)value);
	else return value.ToString();
	end if
end function

function string GetCSharpOperator(MetaOperatorExpression expr)
	switch(expr)
		type as MetaUnaryPlusExpression: return "+";
		type as MetaNegateExpression: return "-";
		type as MetaOnesComplementExpression: return "~";
		type as MetaNotExpression: return "!";
		type as MetaPostIncrementAssignExpression: return "++";
		type as MetaPostDecrementAssignExpression: return "--";
		type as MetaPreIncrementAssignExpression: return "++";
		type as MetaPreDecrementAssignExpression: return "--";
		type as MetaMultiplyExpression: return "*";
		type as MetaDivideExpression: return "/";
		type as MetaModuloExpression: return "%";
		type as MetaAddExpression: return "+";
		type as MetaSubtractExpression: return "-";
		type as MetaLeftShiftExpression: return "<<";
		type as MetaRightShiftExpression: return ">>";
		type as MetaLessThanExpression: return "<";
		type as MetaLessThanOrEqualExpression: return "<=";
		type as MetaGreaterThanExpression: return ">";
		type as MetaGreaterThanOrEqualExpression: return ">=";
		type as MetaEqualExpression: return "==";
		type as MetaNotEqualExpression: return "!=";
		type as MetaAndExpression: return "&";
		type as MetaOrExpression: return "|";
		type as MetaExclusiveOrExpression: return "^";
		type as MetaAndAlsoExpression: return "&&";
		type as MetaOrElseExpression: return "||";
		type as MetaNullCoalescingExpression: return "??";
		type as MetaMultiplyAssignExpression: return "*=";
		type as MetaDivideAssignExpression: return "/=";
		type as MetaModuloAssignExpression: return "%=";
		type as MetaAddAssignExpression: return "+=";
		type as MetaSubtractAssignExpression: return "-=";
		type as MetaLeftShiftAssignExpression: return "<<=";
		type as MetaRightShiftAssignExpression: return ">>=";
		type as MetaAndAssignExpression: return "&=";
		type as MetaExclusiveOrAssignExpression: return "^=";
		type as MetaOrAssignExpression: return "|=";
		default: return "";
	end switch
end function

function string GetTypeName(MetaExpression expr)
	if (expr is MetaTypeOfExpression) return ((MetaTypeOfExpression)expr).TypeReference.CSharpName();
	else return null;
	end if
end function

function MetaSynthetizedPropertyInitializer GetSynthetizedInitializerFor(MetaClass cls, MetaProperty prop)
	MetaSynthetizedPropertyInitializer lastInit = null;
	loop(cls->sup:GetAllSuperClasses(true)->Constructor->Initializers->init:typeof(MetaSynthetizedPropertyInitializer))
		if (init.Property == prop)
			lastInit = init;
		end if
	end loop
	return lastInit;
end function

template GenerateConstructorImpl(MetaModel model, MetaClass cls)
public [cls.CSharpImplName()]() 
    : this(true)
{
}

public [cls.CSharpImplName()](bool addToModelContext) 
    : base(addToModelContext)
{
	[loop(cls->prop:GetAllProperties())]
		[MetaSynthetizedPropertyInitializer synInit = GetSynthetizedInitializerFor(cls, prop)]
		[if (synInit != null)]
			[if (prop.Kind != MetaPropertyKind.Derived)]
				[if (ModelContext.Current.Compiler.TypeProvider.GetTypeOf(synInit.Value) is MetaCollectionType)]
    this.MLazySet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, new Lazy<object>(() => [GenerateExpression(synInit.Value)]));
				[else]
    this.MLazySet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, new Lazy<object>(() => [GenerateExpression(synInit.Value)]));
				[end if]
			[end if]
		[else]
			[if(prop.Type is MetaCollectionType)]
				[if (prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment)]
    this.MSet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, new [prop.Type.CSharpName()]([GetCollectionConstructorParams(prop)]));
				[else if (prop.Kind == MetaPropertyKind.Lazy)]
    this.MLazySet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, new Lazy<object>(() => [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this)));
				[else if (prop.Kind == MetaPropertyKind.Readonly)]
    // Init [model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property in [model.CSharpName()]Implementation.[cls.CSharpName()]_[cls.CSharpName()]
				[end if]
			[else]
				[if(prop.Kind == MetaPropertyKind.Lazy)]
    this.MLazySet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property, new Lazy<object>(() => [model.CSharpName()]ImplementationProvider.Implementation.[prop.Class.CSharpName()]_[prop.Name](this)));
				[else if (prop.Kind == MetaPropertyKind.Readonly)]
    // Init [model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property in [model.CSharpName()]Implementation.[cls.CSharpName()]_[cls.CSharpName()]
				[end if]
			[end if]
		[end if]
	[end loop]
	[loop(cls->sup:GetAllSuperClasses(true)->Constructor->Initializers->init:typeof(MetaInheritedPropertyInitializer))]
		[if (init.Object != null && init.Property != null)]
    this.MLazySetChild([init.Object.Class.Model.CSharpFullName()].[init.Object.Class.CSharpName()].[init.Object.Name]Property, [init.Property.Class.Model.CSharpFullName()].[init.Property.Class.CSharpName()].[init.Property.Name]Property, new Lazy<object>(() => [GenerateExpression(init.Value)]));
		[end if]
	[end loop]
    [cls.Model.CSharpName()]ImplementationProvider.Implementation.[cls.CSharpName()]_[cls.CSharpName()](this);
    [loop(cls->prop:GetAllProperties())]
		[if (prop.Kind == MetaPropertyKind.Readonly)]
    if (!this.MIsSet([model.CSharpFullName()].[prop.Class.CSharpName()].[prop.Name]Property)) throw new ModelException("Readonly property [model.CSharpName()].[prop.Class.CSharpName()].[prop.Name]Property was not set in [cls.CSharpName()]_[cls.CSharpName()]().");
		[end if]
	[end loop]
    this.MMakeDefault();
}
end template

function string GetReturn(MetaOperation op)
    if (op.ReturnType.CSharpName() == "void") 
		return "";
	else 
		return "return ";
	end if
end function

template GenerateOperationImpl(MetaModel model, MetaOperation op)
^
[op.ReturnType.CSharpPublicName()] [op.Parent.CSharpName()].[op.Name]([GetParameters(op, false)])
{
    [GetReturn(op)][model.CSharpName()]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetImplCallParameterNames(op)]);
}
end template

function string GetSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:SuperClasses; string delim = ""; delim = ", ")
		result += delim+sup.CSharpName();
	end loop
	return result;
end function

function string GetAllSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:GetAllSuperClasses(false); string delim = ""; delim = ", ")
		result += delim+sup.CSharpName();
	end loop
	return result;
end function

template GenerateMetaModel(MetaModel model)
public static class [model.CSharpName()]
{
	internal static global::MetaDslx.Core.Model model;
^
    static [model.CSharpName()]()
    {
	    [model.CSharpName()].model = new global::MetaDslx.Core.Model();
    [loop(model->Types->cls:typeof(MetaClass))]
        [cls.CSharpName()].StaticInit();
        model.AddInstance((global::MetaDslx.Core.ModelObject)[cls.CSharpName()].Instance);
    [end loop]
    }
^
    internal static void StaticInit()
    {
    }
^
    public static MetaDslx.Core.Model Model
    {
        get { return [model.CSharpName()].model; }
    }
^
    public static class Constants
    {
        static Constants()
        {
    [loop(model->c:Constants)]
            [GenerateModelConstantImpl(c)]
    [end loop]
^
    [loop(model->f:Functions)]
            [GenerateModelFunctionImpl(f)]
    [end loop]
        }
^
    [loop(model->c:Constants)]
        [GenerateModelConstant(c)]
    [end loop]
^
    [loop(model->f:Functions)]
        [GenerateModelFunction(f)]
    [end loop]
    }
^
    [loop(model->Types->cls:typeof(MetaClass))]
    [GenerateMetaModelClass(cls)]
    [end loop]
}
^
end template

template GenerateMetaModelClass(MetaClass cls)
^
public static class [cls.CSharpName()]
{
	internal static global::MetaDslx.Core.MetaClass instance;

    internal static void StaticInit()
    {
    }
^
    static [cls.CSharpName()]()
    {
        [cls.Model.CSharpFullName()].StaticInit();
        [cls.CSharpName()].instance = global::MetaDslx.Core.MetaModelFactory.Instance.CreateMetaClass(false);
		[if (cls.IsAbstract)]
		[cls.CSharpName()].instance.IsAbstract = true;
		[end if]
        [cls.CSharpName()].instance.Name = "[cls.CSharpName()]";
		[loop(cls->sup:SuperClasses)]
        ((ModelCollection)[cls.CSharpName()].instance.SuperClasses).MLazyAdd(new Lazy<object>(() => [sup.Model.CSharpFullName()].[sup.CSharpName()].Instance));
		[end loop]
    }
^
    public static global::MetaDslx.Core.MetaClass Instance
    {
        get { return [cls.CSharpName()].instance; }
    }
^
    [loop(cls->prop:Properties)]
    [GeneratePropertyDeclaration(cls.Model, cls, prop)]
    [end loop]
}
end template


template GenerateModelConstant(MetaConstant mconst)
public static [mconst.Type.CSharpFullName()] [mconst.Name] { get; private set; }
end template

template GenerateModelFunction(MetaFunction mfunc)
public static global::MetaDslx.Core.MetaFunction [mfunc.Name] { get; private set; }
end template

template GenerateModelConstantImpl(MetaConstant mconst)
[GenerateConstantValueExpression(mconst.Name, mconst.Value, null)]
end template

template GenerateModelFunctionImpl(MetaFunction mfunc)
[mfunc.Name] = global::MetaDslx.Core.MetaModelFactory.Instance.CreateMetaFunction();
[if (hasloop(mfunc->a:Annotations where a.Name == "Name"))]
	[loop(mfunc->a:Annotations->p:Properties where a.Name == "Name" && p.Name == "Name")]
[mfunc.Name].Name = [GenerateExpression(p.Value)];
	[end loop]
[else]
[mfunc.Name].Name = "[mfunc.Name]";
[end if]
[GenerateModelFunctionImplTypeOf(mfunc.Name+".ReturnType", mfunc.ReturnType)]
[loop(mfunc->p:Parameters)]
[string tmpName = "tmp"+NextCounter()]
global::MetaDslx.Core.MetaParameter [tmpName] = global::MetaDslx.Core.MetaModelFactory.Instance.CreateMetaParameter();
[tmpName].Name = "[p.Name]";
[GenerateModelFunctionImplTypeOf(tmpName+".Type", p.Type)]
[mfunc.Name].Parameters.Add([tmpName]);
[end loop]
end template

template GenerateModelFunctionImplTypeOf(string name, MetaType mtype)
[switch(mtype)]
[type as MetaCollectionType:]
[string tmpName = "tmp"+NextCounter()]
global::MetaDslx.Core.MetaCollectionType [tmpName] = global::MetaDslx.Core.MetaModelFactory.Instance.CreateMetaCollectionType();
[name] = [tmpName];
[tmpName].Kind = MetaCollectionKind.[mtype.Kind];
[GenerateModelFunctionImplTypeOf(tmpName+".InnerType", mtype.InnerType)]
[default:][name] = [GenerateTypeOf(mtype)];
[end switch]
end template

template GenerateImplementationProvider(MetaModel model)
internal static class [model.CSharpName()]ImplementationProvider
{
    // If there is a compile error at this line, create a new class called [model.CSharpName()]Implementation
	// which is a subclass of [model.CSharpName()]ImplementationBase:
    private static [model.CSharpName()]Implementation implementation = new [model.CSharpName()]Implementation();
^
    public static [model.CSharpName()]Implementation Implementation
    {
        get { return [model.CSharpName()]ImplementationProvider.implementation; }
    }
}
	[loop(model->Types->enm:typeof(MetaEnum))]
^
public static class [model.CSharpName()][enm.Name]Extensions
{
    [loop(enm->op:Operations)]
    public static [op.ReturnType.CSharpPublicName()] [op.Name]([GetEnumImplParameters(enm, op)])
    {
        [GetReturn(op)][model.CSharpName()]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetEnumImplCallParameterNames(op)]);
    }
	[end loop]
}
	[end loop]
^
/// <summary>
/// Base class for implementing the behavior of the model elements.
/// This class has to be be overriden in [model.CSharpName()]Implementation to provide custom
/// implementation for the constructors, operations and property values.
/// </summary>
internal abstract class [model.CSharpName()]ImplementationBase
{
	[loop(model->Types->cls:typeof(MetaClass))]
    /// <summary>
	/// Implements the constructor: [cls.CSharpName()]()
	[if (hasloop(cls->sup:SuperClasses))]
	/// Direct superclasses: [GetSuperClasses(cls)]
	/// All superclasses: [GetAllSuperClasses(cls)]
	[end if]
	[if (hasloop(cls->prop:GetAllProperties() where prop.Kind == MetaPropertyKind.Readonly))]
    // Initializes the following readonly properties:
	[end if]
    [loop(cls->prop:GetAllProperties())]
	[if (prop.Kind == MetaPropertyKind.Readonly)]
    ///    [prop.Class.Name].[prop.Name]
	[end if]
	[end loop]
    /// </summary>
    public virtual void [cls.CSharpName()]_[cls.CSharpName()]([cls.CSharpName()] @this)
    {
		[loop(cls->sup:SuperClasses)]
        this.[sup.CSharpName()]_[sup.CSharpName()](@this);
		[end loop]
    }
    [loop(cls->prop:Properties)]
		[MetaSynthetizedPropertyInitializer synInit = GetSynthetizedInitializerFor(cls, prop)]
		[if (synInit == null)]
			[if (prop.Kind == MetaPropertyKind.Derived)]
^
    /// <summary>
    /// Returns the value of the derived property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
			[else if (prop.Kind == MetaPropertyKind.Lazy)]
^
    /// <summary>
    /// Returns the value of the lazy property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
			[end if]
		[end if]
	[end loop]
    [loop(cls->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [cls.CSharpName()].[op.Name]()
    /// </summary>
    public virtual [op.ReturnType.CSharpPublicName()] [cls.CSharpName()]_[op.Name]([GetImplParameters(cls, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
	[loop(model->Types->enm:typeof(MetaEnum))]
    [loop(enm->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [enm.CSharpName()].[op.Name]
    /// </summary>
    public virtual [op.ReturnType.CSharpPublicName()] [enm.CSharpName()]_[op.Name]([GetImplParameters(enm, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
}
^
end template

template GenerateFactory(MetaModel model)
/// <summary>
/// Factory class for creating instances of model elements.
/// </summary>
public class [model.Name]Factory : ModelFactory
{
    private static [model.Name]Factory instance = new [model.Name]Factory();
^
	private [model.Name]Factory()
	{
	}
^
    /// <summary>
    /// The singleton instance of the factory.
    /// </summary>
    public static [model.Name]Factory Instance
    {
        get { return [model.Name]Factory.instance; }
    }
	[loop(model->Types->cls:typeof(MetaClass))]
		[if (!cls.IsAbstract)]
^
    /// <summary>
    /// Creates a new instance of [cls.CSharpName()].
    /// </summary>
    public [cls.CSharpName()] Create[cls.CSharpName()](bool addToModelContext = true)
	{
		[cls.CSharpName()] result = new [cls.CSharpFullName()]Impl(addToModelContext);
		return result;
	}
		[end if]
	[end loop]
}
^
end template
